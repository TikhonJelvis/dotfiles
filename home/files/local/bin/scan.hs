#!/usr/bin/env nix-shell
#!nix-shell -i runhaskell -p img2pdf -p "haskellPackages.ghcWithPackages (ps: [ps.turtle])"

{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ViewPatterns #-}

-- | This script lets me scan multiple pages interactively, combining
-- the result into a single PDF.
module Main where

import Prelude hiding (FilePath)

import qualified Control.Foldl as Fold

import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.IO as Text

import qualified Options.Applicative as Opt

import Text.Printf (printf)

import Turtle hiding (printf)

main :: IO ()
main = sh $ do
  guessed <- need "XDG_CACHE_HOME" >>= \case
    Just (fromText -> xdgCache) -> do
      cache (xdgCache </> "scan-hs-list") guessScannerName
    Nothing -> guessScannerName

  ScanOptions { device, pngPath, pdfPath } <-
    options "Scan a number of documents into a single PDF." $ scanOptions guessed

  liftIO $ printf "Scanning documents to: %s\n" (toText' pdfPath)
  liftIO $ printf "with: %s\n" device

  png <- case pngPath of
    Just path -> do
      liftIO $ printf "Writing per-page pngs to: %s" (toText' path)
      path <$ mktree path
    Nothing   -> mktempdir "/tmp" "scan-hs"

  let scan = do
        scanPages device png
        when' pngPath $ \ png -> 
          liftIO $ printf "Scanned pages to %s\n" (toText' png)

  testfile (png </> "0" <.> "png") >>= \case
    True -> do
      liftIO $ printf "%s contains previous scan results. Overwrite? [yN]\n" (toText' png)
      prompt "N" $ scan
    False -> scan

  toPdf png pdfPath
  liftIO $ printf "Saved PDF: %s\n" (toText' pdfPath)

  where when' value action = case value of
          Just x  -> action x
          Nothing -> pure ()
  
-- ** Scanning

-- | Interactively scan pages one at a time, saving them in the given
-- out directory.
--
-- Each page will be saved as @0.png@, @1.png@... etc.
scanPages :: Text -> FilePath -> Shell ()
scanPages device outPath = go 0
  where go n = do
          echo "Scan next page? [Yn]"
          prompt "Y" $ do
            let out  = toText' (outPath </> repr n <.> "png")
            procs "scanimage" ["-d", device, "--format", "png", "--output-file", out] empty
            go (n + 1)

-- | Convert all the numbered PNG files in the given directory to a
-- PDF.
--
-- This expects files called 0.png, 1.png... etc—same as generated by
-- @'scanPages'@.
--
-- Uses the img2pdf utility under the hood.
toPdf :: FilePath
         -- ^ The directory to look for PNG files.
      -> FilePath
         -- ^ Output directory to write PDF file.
      -> Shell ()
toPdf png pdfPath = do
  pagePaths <- sortOn page $ findtree pagePng $ ls png
  let pages = toText' <$> pagePaths
  procs "img2pdf" (["--output", toText' pdfPath] <> pages) empty
  where pagePng = suffix $ "/" *> decimal <* ".png"
        page = head . match pagePng . toText'

-- | Wait for a Y/N input from the user, then execute a follow-up
-- action.
--
-- On @Y@, @y@, execute the follow-up action.
--
-- On @N@, @n@ or EOF, return () without executing the follow-up
-- action.
--
-- On any other input, re-prompt with an error message.
prompt :: Text -> Shell () -> Shell ()
prompt def next = readline >>= \case
  Just "" -> go (Just def)
  other   -> go (lineToText <$> other)
  where go = \case
          Just "Y"    -> next
          Just "y"    -> next

          Just "N"    -> pure ()
          Just "n"    -> pure ()
          Just "\EOT" -> pure ()
          Nothing     -> pure ()

          Just wrong  -> do
            liftIO $ printf "Please enter Y or N, not “%s”.\n" wrong
            prompt def next

toText' :: FilePath -> Text
toText' = either invalidPath id . toText
  where invalidPath path = error $ printf "‘%s’ is not a valid UTF-8-encoded path!"

-- ** Command-Line Options

data ScanOptions = ScanOptions
  { device  :: Text
  , pngPath :: Maybe FilePath
  , pdfPath :: FilePath
  }

scanOptions :: Maybe Text -> Parser ScanOptions
scanOptions guessed = ScanOptions
  <$> device
  <*> optional pngPath
  <*> pdfPath
  where deviceHelp = case guessed of
          Just device -> printf " (Default: ‘%s’)" device
          Nothing     -> ""
        deviceDefault = case guessed of
          Just device -> Opt.value device
          Nothing     -> mempty
        device = Opt.strOption
          ( Opt.short 'd'
         <> Opt.long "device"
         <> Opt.help ("Device name for scanimages." <> deviceHelp)
         <> deviceDefault
          )

        pngPath = Opt.strOption
          ( Opt.long "pngs"
         <> Opt.help "Output directory to write pngs to."
          )

        pdfPath = Opt.strOption
          ( Opt.long "out"
         <> Opt.short 'o'
         <> Opt.help "Path to write a consolidated PDF."
          )
         
-- ** Device Names

-- | Guess the scanner name by looking for "CANON" in the output of
-- @scanimage -L@. Hey, it works for me!
--
-- If there are multiple matching outputs in @scanimage -L@, returns
-- the first one.
--
-- If there are no matching outputs in @scanimage -L@, returns
-- @Nothing@.
guessScannerName :: Shell (Maybe Text)
guessScannerName = reduce Fold.head $ do
  device <- lineToText <$> inproc "scanimage" ["-L"] empty
  case match deviceName device of
    (name : _) -> pure name
    []         -> empty

-- | A pattern that extracts the device name from a single line of
-- @scanimage -L@ output.
--
-- The output for my personal scanner is:
--
-- @
-- device `pixma:04A91912_464BEF' is a CANON CanoScan LiDE 400 multi-function peripheral
-- @
--
-- so I look for lines that include @is a CANON@.
deviceName :: Pattern Text
deviceName = do
  text "device `"
  name <- star $ noneOf ['\'']
  text "' is a "
  asciiCI "CANON"
  chars
  pure name
